#!/usr/bin/env python3
"""
Analyze cProfile results and extract key bottlenecks.

Usage:
    python benchmarks/analyze_cprofile.py profiling_results/phase1/cprofile_baseline.prof
"""

import argparse
import pstats
import sys
from pathlib import Path


def analyze_profile(profile_path: Path, top_n: int = 20):
    """Analyze a cProfile .prof file and extract bottlenecks."""

    if not profile_path.exists():
        print(f"Error: Profile file not found: {profile_path}")
        sys.exit(1)

    print(f"\n{'='*80}")
    print(f"Analyzing: {profile_path}")
    print(f"{'='*80}\n")

    # Load profile stats
    stats = pstats.Stats(str(profile_path))

    # Sort by cumulative time
    print(f"## Top {top_n} Functions by Cumulative Time\n")
    print("These functions (and their callees) consume the most total time:\n")
    stats.sort_stats("cumulative")
    stats.print_stats(top_n)

    print(f"\n{'='*80}\n")

    # Sort by internal time
    print(f"## Top {top_n} Functions by Internal Time\n")
    print("These functions consume the most time themselves (excluding callees):\n")
    stats.sort_stats("time")
    stats.print_stats(top_n)

    print(f"\n{'='*80}\n")

    # Sort by call count
    print(f"## Top {top_n} Functions by Call Count\n")
    print("These functions are called most frequently:\n")
    stats.sort_stats("calls")
    stats.print_stats(top_n)

    print(f"\n{'='*80}\n")

    # Extract key bottlenecks for structured output
    stats.sort_stats("cumulative")

    bottlenecks = []
    for func, (cc, nc, tt, ct, callers) in list(stats.stats.items())[:top_n]:
        filename, line, func_name = func
        bottlenecks.append(
            {
                "function": func_name,
                "file": filename,
                "line": line,
                "cumulative_time": ct,
                "internal_time": tt,
                "calls": nc,
                "time_per_call": ct / nc if nc > 0 else 0,
            }
        )

    # Print summary
    print("## Summary of Key Bottlenecks\n")
    print(
        f"{'Rank':<6} {'Function':<40} {'Cumulative':<12} {'Internal':<12} {'Calls':<10}"
    )
    print("-" * 80)

    for i, bottleneck in enumerate(bottlenecks[:10], 1):
        func_display = bottleneck["function"][:38]
        print(
            f"{i:<6} {func_display:<40} {bottleneck['cumulative_time']:>10.3f}s  "
            f"{bottleneck['internal_time']:>10.3f}s  {bottleneck['calls']:>8}"
        )

    print(f"\n{'='*80}\n")

    # Generate recommendations
    print("## Optimization Recommendations\n")

    hot_functions = [b for b in bottlenecks[:5]]

    for i, func in enumerate(hot_functions, 1):
        print(f"{i}. **{func['function']}**")
        print(f"   - File: `{func['file']}:{func['line']}`")
        print(f"   - Cumulative time: {func['cumulative_time']:.3f}s")
        print(
            f"   - Called {func['calls']} times ({func['time_per_call']*1000:.2f}ms per call)"
        )

        # Provide context-specific recommendations
        func_name = func["function"].lower()
        if "observation" in func_name or "perceive" in func_name:
            print("   - ðŸ’¡ Consider caching observations for stationary agents")
            print("   - ðŸ’¡ Profile bilinear interpolation overhead")
        elif "spatial" in func_name or "kdtree" in func_name or "query" in func_name:
            print("   - ðŸ’¡ Tune batch update parameters")
            print("   - ðŸ’¡ Consider alternative index types for this workload")
        elif "log" in func_name or "database" in func_name or "db" in func_name:
            print("   - ðŸ’¡ Increase batch buffer sizes")
            print("   - ðŸ’¡ Consider async logging")
        elif "update" in func_name:
            print("   - ðŸ’¡ Profile individual update components")
            print("   - ðŸ’¡ Check for unnecessary computations")
        elif "act" in func_name or "decide" in func_name:
            print("   - ðŸ’¡ Consider batching agent decisions")
            print("   - ðŸ’¡ Profile RL algorithm overhead")

        print()

    print(f"{'='*80}\n")


def main():
    parser = argparse.ArgumentParser(
        description="Analyze cProfile results to identify bottlenecks"
    )
    parser.add_argument(
        "profile_file",
        type=Path,
        help="Path to .prof file generated by cProfile",
    )
    parser.add_argument(
        "--top",
        type=int,
        default=20,
        help="Number of top functions to display (default: 20)",
    )

    args = parser.parse_args()

    analyze_profile(args.profile_file, args.top)


if __name__ == "__main__":
    main()
